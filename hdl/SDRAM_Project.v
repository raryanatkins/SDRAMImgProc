
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module SDRAM_Project(

	//////////// CLOCK //////////
	input 		          		ADC_CLK_10,
	input 		          		MAX10_CLK1_50,
	input 		          		MAX10_CLK2_50,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// SEG7 //////////
	output		     [7:0]		HEX0,
	output		     [7:0]		HEX1,
	output		     [7:0]		HEX2,
	output		     [7:0]		HEX3,
	output		     [7:0]		HEX4,
	output		     [7:0]		HEX5,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// VGA //////////
	output reg		  [3:0]		VGA_B,
	output reg		  [3:0]		VGA_G,
	output reg		       		VGA_HS,
	output reg		  [3:0]		VGA_R,
	output reg		       		VGA_VS
);

//=======================================================
//  Parameter declarations
//=======================================================

// Number of bits read at a time from the QSYS system
localparam DATA_WIDTH  				= 16;
localparam ADDR_WIDTH				= 25;

localparam INTERFACE_WIDTH_BYTES = DATA_WIDTH / 8;

// State machine
localparam WRITE					 	 = 0;
localparam IDLE            	 	 = 1;
localparam BUFFER						 = 2;

localparam BITS_PER_PIXEL        = 16;

// Number of transfers that have to be done to fill the line buffer
// Need 640 pixels in each line (one row), therefore 640 reads from the SDRAM
localparam NUM_TRANSFERS_PER_LINE = 640;

// Number of bits needed to address the buffer.
localparam BUFFER_ADDR_WIDTH = 10;

localparam COL_WIDTH = 10;
localparam ROW_WIDTH = 9;

//=======================================================
//  REG/WIRE declarations
//=======================================================

// Only one DQM port, wire together
wire 	 DRAM_DQM;
assign DRAM_LDQM = DRAM_DQM;
assign DRAM_UDQM = DRAM_DQM;

// Reset control
wire reset_n;
assign reset_n = KEY[0];

// Interface signals
reg  [ADDR_WIDTH-1:0] 				interface_address;
wire [INTERFACE_WIDTH_BYTES-1:0] interface_byteenable;
wire 										interface_chipselect;
wire [DATA_WIDTH-1:0] 				interface_writedata;
reg 										interface_read;
reg 										interface_write;
wire [DATA_WIDTH-1:0] 				interface_readdata;
wire 										interface_readdatavalid;
wire 										interface_waitrequest;

// Always read all bytes at a time.
assign interface_byteenable = (2 ** INTERFACE_WIDTH_BYTES) - 1;
// Always allow SDRAM commands
assign interface_chipselect = 1'b1;

// PLL clock outputs (system_clock = 100MHz, vga_clk = 25MHz)
wire										system_clock, vga_clk;

////////////////////////////////////////////////////////////////////////////////
// QSYS System Instantiation
////////////////////////////////////////////////////////////////////////////////
system u0 (
	.clk_clk                 (MAX10_CLK1_50),
	.reset_reset_n           (reset_n),
	.sdram_addr              (DRAM_ADDR),
	.sdram_ba                (DRAM_BA),
	.sdram_cas_n             (DRAM_CAS_N),
	.sdram_cke               (DRAM_CKE),
	.sdram_cs_n              (DRAM_CS_N),
	.sdram_dq                (DRAM_DQ),
	.sdram_dqm               (DRAM_DQM),
	.sdram_ras_n             (DRAM_RAS_N),
	.sdram_we_n              (DRAM_WE_N),
	.sdram_clk_100_clk		 (DRAM_CLK),
	.interface_address       (interface_address),
	.interface_byteenable_n  (~interface_byteenable),	
	.interface_chipselect    (interface_chipselect),
	.interface_writedata     (interface_writedata),
	.interface_read_n        (~interface_read),
	.interface_write_n       (~interface_write),
	.interface_readdata      (interface_readdata),
	.interface_readdatavalid (interface_readdatavalid),
	.interface_waitrequest   (interface_waitrequest),
	.system_clock_clk			 (system_clock),
	.vga_clk_clk				 (vga_clk)
);

////////////////////////////////////////////////////////////////////////////////
// VGA Timer instantiation
////////////////////////////////////////////////////////////////////////////////
vga_timer u1 (
    .clk        (vga_clk),
    .reset_n    (reset_n),
    .h_sync     (h_sync),
    .v_sync     (v_sync),
    .disp_ena   (disp_ena),
    .col        (col),
    .row        (row)
);


wire [12:0] random;
lfsr u2 (
	.clock		(system_clock),
	.rnd			(random)
);
	


//=======================================================
//  Structural coding / State Machine
//=======================================================

reg write_complete, write_complete_next;
reg [ADDR_WIDTH-1:0] interface_address_next;
reg [1:0] buffer_state, buffer_state_next;
reg timing_error, timing_error_next;

// Debugging outputs
assign LEDR[0] = timing_error;
assign LEDR[9] = write_complete;


//=======================================================
//  TESTS
//=======================================================

// TEST 1:
// Test writing top half of the screen red, bottom half blue
assign interface_writedata = interface_address < 153600 ? 16'h0f00 : 16'h000f;

// TEST 2:
// Test cutting off red in the middle of the next row
//assign interface_writedata = interface_address < 153920 ? 16'h0f00 : 16'h000f;

// TEST 3:
// Test 3/4 of the screen red, 1/4 blue
//assign interface_writedata = interface_address < 230400 ? 16'h0f00 : 16'h000f;

// TEST 4:
//assign interface_writedata = random[11:0];

// Next state assignments
always @(posedge system_clock) begin
   buffer_state          <= buffer_state_next;
	interface_address		 <= interface_address_next;
	write_complete			 <= write_complete_next;
   line_buffer_write_addr<= line_buffer_write_addr_next;
	timing_error			 <= timing_error_next;
end

// Next state logic
always @(*) begin
   // Default holding logic.
   buffer_state_next            = buffer_state;
	interface_address_next		  = interface_address;
	write_complete_next			  = write_complete;
   line_buffer_write_addr_next  = line_buffer_write_addr;
	timing_error_next				  = timing_error;
	
   // Default outputs.
   line_buffer_write_enable = 1'b0;
   interface_read = 1'b0;
	interface_write = 1'b0;

   case (buffer_state)
		WRITE: begin
			timing_error_next = 1'b0;
			write_complete_next = 1'b0;
			interface_write = 1'b1;
					
			// Increment address after successful write
			if(~interface_waitrequest) begin
				interface_address_next = interface_address + 1'b1;
			end
				
			// Iterate through entire memory
			if(interface_address == 25'h4b000) begin //25'h1ffffff) begin
				write_complete_next = 1'b1;
					
				// Next state and address reset
				buffer_state_next = IDLE;
			end
		 end // write
		  
		
		IDLE: begin
			// Wait until falling edge of disp_ena. This indicates that a row
         // has just been written to the display and we should begin
         // buffering data during the downtime of h_sync.
         if (start_buffering) begin
				interface_address_next = NUM_TRANSFERS_PER_LINE * next_row;
				// Zero out the column we are reading.
				line_buffer_write_addr_next = 0;
				// Branch to the buffering state
				buffer_state_next = BUFFER;
			end
		end // idle
		

		BUFFER: begin
			if(start_buffering)
				timing_error_next = 1'b1;
			// Loop until all pixels in the column have been buffered.
			if (line_buffer_write_addr < NUM_TRANSFERS_PER_LINE) begin
				interface_read = 1'b1;
				 
				// Don't do anything unless the interface returns readdatavalid
				if (interface_readdatavalid) begin
					line_buffer_write_enable = 1'b1;
					line_buffer_write_addr_next = line_buffer_write_addr + 1'b1;
					interface_address_next = NUM_TRANSFERS_PER_LINE * next_row + line_buffer_write_addr_next;
				end
			end
			else begin
				buffer_state_next = IDLE;
			end
		end // buffer
		

		
	endcase
end

///////////////////////////////////////////////////////////////////////////////
// LINE BUFFER
///////////////////////////////////////////////////////////////////////////////

// Line buffer builds a memory containing one row of the image at a time (640 pixels)
// This handles the different clock domains of the SDRAM and VGA
wire [ROW_WIDTH-1:0] 			next_row;
// Line buffer memory (0-640).
reg [DATA_WIDTH-1:0] 			line_buffer [NUM_TRANSFERS_PER_LINE-1:0];
// Line buffer write signals
reg                     		line_buffer_write_enable;
reg [BUFFER_ADDR_WIDTH-1:0]   line_buffer_write_addr, line_buffer_write_addr_next;
// Line buffer read signals
reg [DATA_WIDTH-1:0]  			line_buffer_read_data;

wire [BITS_PER_PIXEL-1:0] 		pixel;


// Writes - align with system clock
always @(posedge system_clock) begin
	// Save pixel data stored in SDRAM to the buffer
   if (line_buffer_write_enable) begin
		line_buffer[line_buffer_write_addr] <= interface_readdata;
   end
end

// Reads - align with pixel clock
always @(posedge vga_clk) begin
	// Extract pixel data according to the current column
   line_buffer_read_data <= line_buffer[col];
end

assign pixel = line_buffer_read_data[DATA_WIDTH-1:0];
assign next_row = row == 479 ? 0 : row + 1'b1;

////////////////////////////////////////////////////////////////////////////////
// VGA Implementation
////////////////////////////////////////////////////////////////////////////////

wire disp_ena;
wire start_buffering;
reg [1:0]   disp_ena_history;

// Shift history register
always @(posedge system_clock) begin
    disp_ena_history <= {disp_ena_history[0], disp_ena};
end
// Indicates that a row has been drawn to the screen
assign start_buffering = disp_ena_history == 2'b10;

// ----------- //
// VGA Signals //
// ----------- //

wire h_sync, v_sync;
wire [COL_WIDTH-1:0] col;
wire [ROW_WIDTH-1:0] row;

reg VGA_HS_DELAY;
reg VGA_VS_DELAY;

reg [3:0] red, green, blue;

// VGA Signal Routing.
always @(posedge vga_clk) begin
    VGA_HS_DELAY <= h_sync;
    VGA_VS_DELAY <= v_sync;
    VGA_HS <= VGA_HS_DELAY;
    VGA_VS <= VGA_VS_DELAY;

    if (disp_ena) begin
        red     <= pixel[11:8];
        green   <= pixel[7:4];
        blue    <= pixel[3:0];
    end else begin
        red     <= 4'b0000;
        green   <= 4'b0000;
        blue    <= 4'b0000;
    end

    VGA_R <= red;
    VGA_G <= green;
    VGA_B <= blue;
end

endmodule